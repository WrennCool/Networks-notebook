# 1. Software for network analysis and visualization
# 1. 用于分析和可视化网络的软件

![pic](/Chapter8\C8pic\01.png)

# 2. Running time and computaional complexity
# 2. 运行时间和计算复杂度

**运行时间即为完成算法的总时间**

**算法的计算复杂性表明算法的运行时间如何随输入大小而变化。计算复杂性是衡量计算机算法运行时间的一个指标，是它所处理问题大小的函数**

符号 O(n) 表示运行时间以 n 或更少的常数倍变化，到 n 中的前导顺序 我们说“到前导顺序”是因为可能对运行时间有贡献它随着 n 的增加比这个前导项更慢。

# 3. Sorting network data
# 3. 整理排序网络数据

我们讨论一些将网络数据存储在计算机内存中的最常见方法

## Adjacency matrix
## 3.1 邻接矩阵
以邻接矩阵的形式存储网络在许多方面都很方便。本书中描述的大多数公式和计算都是以邻接矩阵的形式编写的。因此，如果我们将矩阵存储在计算机中，将公式转换为计算机代码并计算相应的量通常是一件小事。

### 增加一条边
要在有向未加权网络中的节点 i 和 j 之间添加一条边，只需将邻接矩阵的第 i 个元素增加 1。要删除相同节点之间的边，将元素减一，其计算复杂度为$O{(1)}$

无向网络稍微改变了这种情况，因为它们由对称矩阵表示。如果我们想在节点 i 和 j 之间添加一条无向边，那么原则上我们应该将邻接矩阵的第 i 个和第 j 个元素都增加一，但实际上这是浪费时间。更好的方法是只更新矩阵上三角形中的元素，而将下三角形留空，知道它的正确值只是镜像

### 缺点

如果我们想快速遍历特定节点的邻居，在**稀疏网络**(节点数远大于边数)上这很麻烦。节点 i 的邻居由邻接矩阵的第 i 行中的非零元素表示，要找到它们，我们必须一一遍历该行的所有元素，寻找那些非零的元素。这需要时间 O(n)（因为那是行的长度），这在大型网络中可能是很多时间，但在稀疏网络上大部分时间都被浪费了，因为邻接矩阵为零

邻接矩阵表示法的另一个缺点是，对于稀疏网络的常见情况，它使计算机内存的使用效率低下。在邻接矩阵的大部分元素为零的网络中，矩阵占用的大部分内存用于存储这些零

| Operation | Adjacency matrix | Adjacency list |
| :-------: | :--------------: | :------------: |
|  Insert   |       O(1)       |      O(1)      |
|  Delete   |       O(1)       |     O(m/n)     |
|   Find    |       O(1)       |     O(m/n)     |
| Enumerate |       O(n)       |     O(m/n      |

 以上为邻接矩阵与邻接列表常见操作时的计算复杂度

## Adjacency list
## 邻接列表
邻接列表即为一个具有两列的二维数组（$2\times n$），第一列表述节点的序号，第二列表述该节点所链接节点的序号

![pic](/Chapter8\C8pic\02.png)

对于该无向无加权网络，采用邻接列表的形式表示如下所示：
| Node | Neighbors |
| ---- | --------- |
| 1    | 3, 4      |
| 2    |
| 3    | 4, 1      |
| 4    | 5, 1, 3   |
| 5    | 4         |
 
对于一个有向网络，邻接列表的第二列只表示该节点所指向或被指向的节点，而非无向网络中所链接的节点。如下所示

![pic](/Chapter8\C8pic\03.png)

| Node  | Incoming edges | Outgoing edges |
| :---: | :------------: | :------------: |
|   1   |       4        |      3, 4      |
|   2   |
|   3   |       1        |       4        |
|   4   |    3, 1, 5     |      5, 1      |
|   5   |       4        |       4        |

对于邻接列表，增加一个边较为简单，仅需在两个节点序号所对应的邻居节点后添加对方的节点序号即可。

查找和删除边较为困难，需要查询节点i与j是否存在连接，即查找i与j的所有邻居节点，并执行所对应的操作。由于节点的邻居列表无特定的排序，所以在查找节点时难免会遍历该列表所有的值。`查找`操作所需的计算复杂度为O（m/n），较邻接矩阵的计算复杂度O（1）。在恒定平均度的稀疏网络中两者相等

当我们需要快速遍历节点的邻居时，邻接表真正发挥作用，这是许多网络计算中的常见操作，如第 8.3.1 节所述。我们可以很容易地做到这一点，只需简单地遍历所存储的节点的邻居列表，这需要的时间与邻居的数量成正比，平均为 c=2m/nx

## 其他表示方式

### hybrid matrix/list representations

