# Shortest path and breadth-first search
# 最短路径以及广度优先搜索

算法描述、运行时间分析以及证明

## breadth-first search 广度优先搜索算法
广度优先搜索算法找到从单个起始节点 s 到同一网络组件中的每个其他节点的最短距离。只需稍作修改，它也可以找到实现每个最短距离所必须采取的路径，如果有多个最短路径，它可以找到所有最短路径。它适用于有向和无向网络，尽管我们的描述将集中于无向情况
### 算法描述
![04](/Chapter8\C8pic\04.png)

基本原理如图 8.1 所示。该算法通过一系列轮次进行。在第一轮中，我们找到 s 的所有邻居，根据定义，它们与 s 的距离为 1。在下一轮中，我们找到距离为 2 的所有邻居的邻居，然后是距离为 3 的邻居的邻居的邻居，依此类推。在每一轮中，我们都会从节点 s 进一步走一步，直到没有节点可供探索（好像k-core的算法，就像是反过来一样）

> 广度优先搜索的更正式定义如下。该算法通过一个一个地为节点分配数字来工作，表示它们与 s 的距离。最初，节点 s 被分配距离 0，所有其他节点都未分配。然后，对于 d 从 0 向上的每个整数值，我们定位所有距离为 d 的节点，找到它们的邻居，并将当前没有指定距离的任何节点标记为距离 d +1。当没有下一个值为 d 的节点时，算法结束

### 算法应用
1. 设定一个`距离数组`，存储每个节点到给定节点的距离。初始化d = 0
2. 遍历所有与给定节点距离为d的点，并返回其节点编号（书中并未返回节点编号，仅对全部节点进行遍历）
3. 查询返回节点是否已存储在`距离数组`中
4. 对所有未进入数组的节点赋值为d+1，并添加节点序号与距离进数组，对已记录节点不做处理
5. 回到第二步操作，直到距离数组无新增节点，循环即可停止

计算得到该数组的计算复杂度为O（n），在每轮遍历中我们都会遍历所有的节点n，遍历r次计算复杂度即为O（r n）

### 优化后算法
理论上我们需要计算网络中某两个节点的最短路径，而非某个节点到网络中其他所有节点的最短路径，因此上述算法仍有较多的改进空间

![04](/Chapter8\C8pic\05.png)
方法1：如上图所示，同时对节点i、j进行一次广度优先搜索，按照步骤将据两点为d的节点保存至距离数组中，当两个程序首次同时对一个节点进行标注后即可停止计算，而节点i、j的距离即为两点至该点距离的总和。

在计算网络的直径时，可以对网络中所有节点进行一次广度优先搜索

### 接近中心性
某节点到所有节点的平均距离的倒数，该参数可以采用广度优先算法计算

### 介数中心性
#### 定义
节点 v 的中介中心性是通过 v 的任意节点对 s 和 t 之间的最短路径的数量。
#### 根据定义的方法
计算介数的最简单方法是直接实现度量的定义：找到 s 和 t 之间的最短路径，然后沿着该路径检查它通过的节点，以查看我们感兴趣的节点 v 是否位于其中。对每个不同的对 s , t 重复这个过程，然后我们可以计算通过 v 的路径的总数。
#### **改良方法**
对于每个节点s，我们从该节点开始执行广度优先搜索，然后构造一个最短路径树，如第8.5.5节所述。我们使用该树来跟踪从每个节点到s的路径，并记下这些路径中有多少经过v。我们对所有s重复此计算，从而得出经过v的最短路径的总数

改良方法在针对大型网络进行计算时具有较低的计算复杂度

